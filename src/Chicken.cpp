
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "Chicken.h"

void Chicken__ctx_type_0_init(Chicken__ctx_type_0 &_output_){
   Chicken__ctx_type_0 _ctx;
   _ctx.w2 = 0.0f;
   _ctx.w1 = 0.0f;
   _output_ = _ctx;
   return ;
}

float Chicken_biquad(Chicken__ctx_type_0 &_ctx, float x0, float b0, float b1, float b2, float a1, float a2){
   float w0;
   w0 = (x0 + (- (_ctx.w1 * a1)) + (- (_ctx.w2 * a2)));
   float y0;
   y0 = ((_ctx.w1 * b1) + (_ctx.w2 * b2) + (b0 * w0));
   float _tmp_21_0;
   _tmp_21_0 = _ctx.w1;
   float _tmp_21_1;
   _tmp_21_1 = w0;
   _ctx.w2 = _tmp_21_0;
   _ctx.w1 = _tmp_21_1;
   return y0;
}

float Chicken_lowpass(Chicken__ctx_type_1 &_ctx, float x, float w0, float q){
   float cos_w;
   cos_w = cosf(w0);
   float alpha;
   alpha = (sinf(w0) / (2.f * q));
   float den;
   den = (1.f + alpha);
   float a1;
   a1 = ((-2.f * cos_w) / den);
   float a2;
   a2 = ((1.f + (- alpha)) / den);
   float b0;
   b0 = ((1.f + (- cos_w)) / (2.f * den));
   float b1;
   b1 = ((1.f + (- cos_w)) / den);
   float b2;
   b2 = ((1.f + (- cos_w)) / (2.f * den));
   return Chicken_biquad(_ctx._inst2,x,b0,b1,b2,a1,a2);
}

float Chicken_slew(Chicken__ctx_type_3 &_ctx, float x, float rate){
   float diff;
   diff = (x + (- _ctx.state));
   float y;
   if(diff > rate){
      y = rate;
   }
   else
   {
      if(diff < (- rate)){
         y = (- rate);
      }
      else
      {
         y = diff;
      }
   }
   _ctx.state = (_ctx.state + y);
   return _ctx.state;
}

void Chicken__ctx_type_4_init(Chicken__ctx_type_4 &_output_){
   Chicken__ctx_type_4 _ctx;
   _ctx.sample = 0.0f;
   Chicken__ctx_type_3_init(_ctx._inst7);
   _output_ = _ctx;
   return ;
}

void Chicken__ctx_type_5_init(Chicken__ctx_type_5 &_output_){
   Chicken__ctx_type_5 _ctx;
   _ctx.process_ret_1 = 0.0f;
   _ctx.process_ret_0 = 0.0f;
   _ctx.mode = false;
   _ctx.knob4 = 0.0f;
   _ctx.knob3 = 0.0f;
   _ctx.knob2 = 0.0f;
   _ctx.knob1 = 0.0f;
   Chicken__ctx_type_1_init(_ctx._inst15);
   Chicken__ctx_type_1_init(_ctx._inst14);
   Chicken__ctx_type_4_init(_ctx._inst12);
   Chicken__ctx_type_4_init(_ctx._inst11);
   Chicken__ctx_type_2_init(_ctx._inst10);
   _output_ = _ctx;
   return ;
}

void Chicken_process(Chicken__ctx_type_5 &_ctx, float clock, float mod1, float mod2){
   if(_ctx.mode == true){
      uint8_t trigger;
      trigger = Chicken_edge(_ctx._inst10,(clock > 0.2f));
      float out1;
      out1 = Chicken_channel(_ctx._inst11,trigger,_ctx.knob1,_ctx.knob2,_ctx.knob3);
      float out2;
      out2 = Chicken_channel(_ctx._inst12,trigger,_ctx.knob1,_ctx.knob2,_ctx.knob3);
      _ctx.process_ret_0 = out1;
      _ctx.process_ret_1 = out2;
      return ;
   }
   else
   {
      float out1;
      out1 = Chicken_lowpass(_ctx._inst14,mod1,_ctx.knob1,_ctx.knob2);
      float out2;
      out2 = Chicken_lowpass(_ctx._inst15,mod2,_ctx.knob3,_ctx.knob4);
      _ctx.process_ret_0 = out1;
      _ctx.process_ret_1 = out2;
      return ;
   }
}


